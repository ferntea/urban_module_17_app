# module_17_1 Структура проекта. Маршруты и модели Pydantic
'''
Подготовка:

    Установите все необходимые библиотеки для дальнейшей работы: fastapi.
    Создайте файлы, структурировав из согласно рисунку:

    Задача "Основные маршруты":
Необходимо создать маршруты и написать Pydantic модели для дальнейшей работы.
Маршруты:
В модуле task.py напишите APIRouter с префиксом '/task' и тегом 'task', а также следующие маршруты, с пустыми функциями:

    get '/' с функцией all_tasks.
    get '/task_id' с функцией task_by_id.
    post '/create' с функцией create_task.
    put '/update' с функцией update_task.
    delete '/delete' с функцией delete_task.

В модуле user.py напишите APIRouter с префиксом '/user' и тегом 'user', а также следующие маршруты, с пустыми функциями:

    get '/' с функцией all_users.
    get '/user_id' с функцией user_by_id.
    post '/create' с функцией create_user.
    put '/update' с функцией update_user.
    delete '/delete' с функцией delete_user.

В файле main.py создайте сущность FastAPI(), напишите один маршрут для неё - '/', по которому функция возвращает словарь - {"message": "Welcome to Taskmanager"}.
Импортируйте объекты APIRouter и подключите к ранее созданному приложению FastAPI, объединив все маршруты в одно приложение.
Схемы:
Создайте 4 схемы в модуле schemas.py, наследуемые от BaseModel, для удобной работы с будущими объектами БД:

    CreateUser с атрибутами: username(str), firstname(str), lastname(str) и age(int)
    UpdateUser с атрибутами: firstname(str), lastname(str) и age(int)
    CreateTask с атрибутами: title(str), content(str), priority(int)
    UpdateTask с теми же атрибутами, что и CreateTask.

Обратите внимание, что 1/2 и 3/4 схемы обладают одинаковыми атрибутами.

Таким образом вы получите подготовленные маршруты и схемы для дальнейшего описания вашего API.
'''


# module_17_2 Модели SQLALchemy. Отношения между таблицами
'''
Подготовка:

    Установите все необходимые библиотеки для дальнейшей работы: sqlalchemy.
    Добавьте файлы в ранее созданную структуру проекта согласно рисунку:

Задача "Модели SQLAlchemy":
Необходимо создать 2 модели для базы данных, используя SQLAlchemy.
База данных и движок:
В модуле db.py:

    Импортируйте все необходимые функции и классы , создайте движок указав пусть в БД - 'sqlite:///taskmanager.db' и 
    локальную сессию (по аналогии с видео лекцией).
    Создайте базовый класс Base для других моделей, наследуясь от DeclarativeBase.

Модели баз данных:
В модуле task.py создайте модель Task, наследованную от ранее написанного Base со следующими атрибутами:

    __tablename__ = 'tasks'
    id - целое число, первичный ключ, с индексом.
    title - строка.
    content - строка.
    priority - целое число, по умолчанию 0.
    completed - булевое значение, по умолчанию False.
    user_id - целое число, внешний ключ на id из таблицы 'users', не NULL, с индексом.
    slug - строка, уникальная, с индексом.
    user - объект связи с таблицей с таблицей User, где back_populates='tasks'.

В модуле user.py создайте модель User, наследованную от ранее написанного Base со следующими атрибутами:

    __tablename__ = 'users'
    id - целое число, первичный ключ, с индексом.
    username - строка.
    firstname - строка.
    lastname - строка.
    age - целое число.
    slug - строка, уникальная, с индексом.
    tasks - объект связи с таблицей с таблицей Task, где back_populates='user'.

После описания моделей попробуйте распечатать SQL запрос в консоль при помощи CrateTable (аналогично видео).

    Не забудьте об импорте одного класса модели в модуль с другим, чтобы таблицы были видны друг другу.
    Для более удобного импорта необходимо дополнить __init__.py в пакете models следующими строками:

from .user import User from .task import Task

Таким образом вы получите 2 модели связанные один(User) ко многим(Task).    
'''

# module_17_3 Миграции. Библиотека alembic
'''
Задача "Миграции alembic":
1. Установите все необходимые библиотеки для дальнейшей работы: alembic.
2. Инициализируйте alembic, у вас должна получится следующая структура:
3. Укажите адрес вашей базы данных 'sqlite:///taskmanager.db' в alembic.ini
4. В env.py импортируйте модели Base, User и Task. Целевой укажите Base.metadata
5. После чего сгенерируйте первую миграцию при помощи alembic revision. Должна появится версия миграции и база данных:
6. Откройте появившуюся базу данных в DB Browser, создастся только 1 таблица - для версий миграций:
7. Выполните команду alembic upgrade head, которая позволит вам применить последнюю миграцию и создать таблицы User, 
Task и запись текущей версии миграции:
Таким образом вы создадите базу данных и 3 реальных таблицы, с данными которых сможете работать в след. домашних 
заданиях.
'''

# module_17_4 Использование БД в маршрутизации. Часть 1
'''
Задача "Маршрутизация пользователя":
Необходимо описать логику функций в user.py используя ранее написанные маршруты FastAPI.
Подготовка:

    Для этого задания установите в виртуальное окружение пакет python-slugify.
    Скачайте этот файл, в нём описана функция-генератор для подключения к БД. Добавьте его в директорию backend.

Подготовьтесь и импортируйте все необходимые классы и функции (ваши пути могут отличаться):
from fastapi import APIRouter, Depends, status, HTTPException
# Сессия БД
from sqlalchemy.orm import Session
# Функция подключения к БД
from backend.db_depends import get_db
# Аннотации, Модели БД и Pydantic.
from typing import Annotated
from models import User
from schemas import CreateUser, UpdateUser
# Функции работы с записями.
from sqlalchemy import insert, select, update, delete
# Функция создания slug-строки
from slugify import slugify

Напишите логику работы функций маршрутов:
Каждая из нижеперечисленных функций подключается к базе данных в момент обращения при помощи функции get_db - Annotated[Session, Depends(get_db)]
Функция all_users ('/'):

    Должна возвращать список всех пользователей из БД. Используйте scalars, select и all

Функция user_by_id ('/user_id'):
Для извлечения записи используйте ранее импортированную функцию select.

    Дополнительно принимает user_id.
    Выбирает одного пользователя из БД.
    Если пользователь не None, то возвращает его.
    В противном случае выбрасывает исключение с кодом 404 и описанием "User was not found"

Функция craete_user ('/create'):
Для добавления используйте ранее импортированную функцию insert.

    Дополнительно принимает модель CreateUser.
    Подставляет в таблицу User запись значениями указанными в CreateUser.
    В конце возвращает словарь {'status_code': status.HTTP_201_CREATED, 'transaction': 'Successful'}
    Обработку исключения существующего пользователя по user_id или username можете сделать по желанию.

Функция update_user ('/update'):
Для обновления используйте ранее импортированную функцию update.

    Дополнительно принимает модель UpdateUser и user_id.
    Если находит пользователя с user_id, то заменяет эту запись значениям из модели UpdateUser. Далее возвращает словарь {'status_code': status.HTTP_200_OK, 'transaction': 'User update is successful!'}
    В противном случае выбрасывает исключение с кодом 404 и описанием "User was not found"

Функция delete_user ('/delete'):
Для удаления используйте ранее импортированную функцию delete.

    Всё должно работать аналогично функции update_user, только объект удаляется.
    Исключение выбрасывать то же.

Создайте, измените и удалите записи через интерфейс Swagger:
Создайте 3 записи User с соответствующими параметрами:

    username: user1, user2, user3
    firstname: Pasha, Roza, Alex
    secondname: Technique, Syabitova, Unknown
    age: 40, 62, 25

Измените запись с id=3: firstname = Bear, secondname = Grylls, age = 50
Удалите запись с id =2.
Выведите всех пользователей.
Проверьте, выбрасываются ли исключения в ваших запросах.
'''

#  main.py

from fastapi import FastAPI
from routers.task import router as task_router
from routers.user import router as user_router
from models import User

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Welcome to Taskmanager"}

app.include_router(task_router)
app.include_router(user_router)
